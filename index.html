<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="zhanghui">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-计算机网络" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2022-09-30T03:02:29.065Z" itemprop="datePublished">2022-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、计算机网络结构"><a href="#一、计算机网络结构" class="headerlink" title="一、计算机网络结构"></a>一、计算机网络结构</h1><h2 id="1、OSI7层网络模型"><a href="#1、OSI7层网络模型" class="headerlink" title="1、OSI7层网络模型"></a>1、OSI7层网络模型</h2><p>Open System Interconnection</p>
<p>8938.html</p>
<p>应用层、表示层、会话层、运输层、网络层、链路层、物理层</p>
<ul>
<li>应用层 （数据）：确定进程之间<strong>通信的性质</strong>以及满足用户需要以及提供网络和用户应用，为应用程序提供服务，DNS，HTTP，HTTPS，DHCP，FTP，POP3（Post Office Protocol）、SMTP（Simple Mail Transfer Protocol）都是这层的协议。</li>
<li>表示层（数据）：主要解决用户信息的<strong>语法表示</strong>问题，表示层提供各种<strong>用于应用层数据的编码和转换功能</strong>,确保一个系统的应用层发送的数据能被另一个系统的应用层识别，<strong>如数据转换，压缩和加密，解密</strong>。</li>
<li>会话层（数据）：会话层就是负责<strong>建立、管理和终止表示层实体之间的通信会话</strong>。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。 比如服务器验证用户登录就是在会话层。</li>
<li>传输层（段）：实现网络不同主机上的用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制，拥塞控制。TCP UDP就这层。</li>
<li>网络层（包）：本层通过<strong>IP寻址</strong>来建立两个节点之间的连接，为源端的运输层送来的分组，<strong>选择合适的路由和交换节点</strong>，正确无误地按照地址传送给目的端的运输层。IP就是这层。</li>
<li>数据链路层（帧）：将上层数据封装成帧，用<strong>MAC</strong>地址访问媒介，并由错误检测和修正</li>
<li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性（常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。）</li>
</ul>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310205342858.png" alt="image-20220310205342858"></p>
<h2 id="2、TCP-IP四层网络模型"><a href="#2、TCP-IP四层网络模型" class="headerlink" title="2、TCP/IP四层网络模型"></a>2、TCP/IP四层网络模型</h2><p>而TCP四层模型就是我们实践过程中发现比较合理的分层，虽然我们实际过程中都没有按OSI分为七层，但是OSI对我们实践过程分层有着指导性的意义。</p>
<p>应用层、运输层、网际层、接口层</p>
<p>应用层，运输层，网络层，链路层。</p>
<p><img src="https://pic2.zhimg.com/80/v2-9120fb10ff256120099cd152799fe309_720w.jpg" alt="img"></p>
<h2 id="3、五层因特网协议栈"><a href="#3、五层因特网协议栈" class="headerlink" title="3、五层因特网协议栈"></a>3、五层因特网协议栈</h2><p>应用层、运输层、网络层、链路层、物理层</p>
<h2 id="4、各层的作用"><a href="#4、各层的作用" class="headerlink" title="4、各层的作用"></a>4、各层的作用</h2><p>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</p>
<p>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</p>
<p>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</p>
<p>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</p>
<p>网络层：负责数据包从源到宿的传递和网际互连（包Packet）</p>
<p>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</p>
<p>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</p>
<h1 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h1><h2 id="1、DNS域名解析系统"><a href="#1、DNS域名解析系统" class="headerlink" title="1、DNS域名解析系统"></a>1、DNS域名解析系统</h2><p>DNS提供域名到IP地址的转换，其工作原理如下</p>
<ol>
<li><p>客户机向其本地域名服务器发出DNS请求报文</p>
</li>
<li><p>本地域名服务器收到请求后，<strong>查询本地缓存</strong>，假设没有该记录，则以DNS客户的身份向<strong>根域名</strong>服务器发出解析请求</p>
</li>
<li><p><strong>根域名</strong>服务器收到请求后，判断该域名所属域，将对应的<strong>顶级域名服务器</strong>的IP地址返回给本地域名服务器</p>
</li>
<li><p>本地域名服务器向<strong>顶级域名服务器</strong>发出解析请求报文</p>
</li>
<li><p>顶级域名服务器收到请求后，将所对应的<strong>授权域名服务器</strong>的IP地址返回给本地域名服务器</p>
</li>
<li><p>本地域名服务器向授权域名服务器发起解析请求报文</p>
</li>
<li><p>授权域名服务器收到请求后，将<strong>查询结果返回给本地域名服务器</strong></p>
</li>
<li><p>本地域名服务器将查询结果保存到<strong>本地缓存</strong>，<strong>同时</strong>返回给客户机</p>
<p>. —- .com —– qq.com —– <a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> –ip给客户机。    </p>
<p>如果是转发模式，则与上一步骤相反，从下往上找。<a target="_blank" rel="noopener" href="http://www.qq.com/">www.qq.com</a> =&gt; qq.com =&gt; .com =&gt; .</p>
</li>
</ol>
<h2 id="2、DNS采用TCP还是UDP，为什么？"><a href="#2、DNS采用TCP还是UDP，为什么？" class="headerlink" title="2、DNS采用TCP还是UDP，为什么？"></a>2、DNS采用TCP还是UDP，为什么？</h2><p>DNS在进行区域传输的时候使用TCP协议，<strong>其它时候则使用UDP协议</strong></p>
<p>TCP与UDP传送字节的长度限制不同，一般情况下一个DNS的UDP包的最大长度是<strong>512</strong>字节</p>
<p>DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。（为什么要有从DNS服务器<a target="_blank" rel="noopener" href="http://baijiahao.baidu.com/s?id=1716562694059215865&amp;wfr=spider&amp;for=pc%EF%BC%89%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%8C%BA%E4%B8%AD%E4%B8%BBDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%8E%E8%87%AA%E5%B7%B1%E6%9C%AC%E6%9C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E8%AF%A5%E5%8C%BA%E7%9A%84DNS%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%80%8C%E8%BE%85%E5%8A%A9DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%99%E4%BB%8E%E5%8C%BA%E7%9A%84%E4%B8%BBDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E8%AF%BB%E5%8F%96%E8%AF%A5%E5%8C%BA%E7%9A%84DNS%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E3%80%82%E5%BD%93%E4%B8%80%E4%B8%AA%E8%BE%85%E5%8A%A9DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%EF%BC%8C%E5%AE%83%E9%9C%80%E8%A6%81%E4%B8%8E%E4%B8%BBDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%EF%BC%8C%E5%B9%B6%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E3%80%82">http://baijiahao.baidu.com/s?id=1716562694059215865&amp;wfr=spider&amp;for=pc）在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息。</a></p>
<p>区域传输使用TCP协议的原因大概是：<br>1） 区域传输的数据量相比单次DNS查询的数据量要大得多<br>2） 区域传输对数据的可靠性和准确性相比普通的DNS查询要要高得多，因此使用TCP协议。</p>
<p><strong>域名解析时一般返回的内容都不超过512字节，首选的通讯协议是UDP。使用UDP传输，不用经过TCP三次握手，这样DNS服务器负载更低，响应更快</strong></p>
<h2 id="2-1-DNS劫持"><a href="#2-1-DNS劫持" class="headerlink" title="2.1 DNS劫持"></a>2.1 DNS劫持</h2><p>DNS劫持：在DNS服务器中，将www.****.com的域名对应的IP地址进行了变化。你解析出来的域名对应的IP，在劫持前后不一样。（要个白菜，回来个土豆）</p>
<p>HTTP劫持：你DNS解析的域名的IP地址不变。在和网站交互过程中的劫持了你的请求。在网站发给你信息前就给你返回了请求。    （要个白菜，回来个烂白菜）</p>
<p>解决dns劫持：1.直接输ip 2.httpdns 使用 https协议，对解析的结果进行了加密，因此防劫持</p>
<h2 id="3、FTP协议"><a href="#3、FTP协议" class="headerlink" title="3、FTP协议"></a>3、FTP协议</h2><p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。</p>
<h2 id="4、http结构（"><a href="#4、http结构（" class="headerlink" title="4、http结构（"></a>4、http结构（</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220317152804720.png" alt="image-20220317152804720"></p>
<h2 id="4、1HTTP请求报文与响应报文首部结构"><a href="#4、1HTTP请求报文与响应报文首部结构" class="headerlink" title="4、1HTTP请求报文与响应报文首部结构"></a>4、1HTTP请求报文与响应报文首部结构</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61506558/article/details/126380760">https://blog.csdn.net/m0_61506558/article/details/126380760</a></p>
<p>HTTP的请求报文由四部分组成（请求行+首部行+空行+实体行） （请求行 请求头 请求体）</p>
<p>HTTP的响应报文也由四部分组成（ 状态行+首部行+空行+实体行）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/LOVEYSUXIN/article/details/81265910">https://blog.csdn.net/LOVEYSUXIN/article/details/81265910</a></p>
<p><img src="https://img-blog.csdn.net/20180728215704882?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xPVkVZU1VYSU4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<blockquote>
<p>GET  /chn/yxsz/index.htm  HTTP/1.1   {请求行使用了相对URL}</p>
<p>Host : <a target="_blank" rel="noopener" href="http://www.tsinghua.edu.cn/">www.tsinghua.edu.cn</a>     {此行是首部行的开始。这行给出了主机的域名}</p>
<p>Connection : close   {告诉服务器发送完请求的文档后就可释放连接，即不使用持续连接}  </p>
<p>User-Agent : Mozilla/5.0   {表明用户代理是使用Netscape浏览器}</p>
<p>Accept-Language : cn  {表明用户希望优先得到中文版本的文档}</p>
<p>///空行</p>
<p>/// 请求报文<img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220901161227681.png" alt="image-20220901161227681"></p>
</blockquote>
<h2 id="5、HTTP1-0、HTTP1-1、HTTP2-0对比"><a href="#5、HTTP1-0、HTTP1-1、HTTP2-0对比" class="headerlink" title="5、HTTP1.0、HTTP1.1、HTTP2.0对比"></a>5、HTTP1.0、HTTP1.1、HTTP2.0对比</h2><p>HTTP1.0：</p>
<p>浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。</p>
<p>HTTP1.1： 长连接</p>
<p>HTTP1.0中默认使用Connection: close。在HTTP1.1中已经默认使用Connection: keep-alive，避免了连接建立和释放的开销，但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。</p>
<p>HTTP2.0:</p>
<p>HTTP/2引入<strong>二进制数据帧和流</strong>的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以<strong>并行</strong>的传输数据，这就是流所做的事情。</p>
<p><strong>多路复用：</strong></p>
<p>1、所有的HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流。</p>
<p>2、每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。</p>
<p>举个例子，每个请求是一个数据流，数据流以消息的方式发送，而消息又分为多个帧，帧头部记录着<strong>stream id</strong>用来标识所属的数据流，不同属的帧可以在连接中随机混杂在一起。接收方可以根据stream id将帧再归属到各自不同的请求当中去。</p>
<p>3、另外，多路复用（连接共享）可能会导致关键请求被阻塞。HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流。</p>
<p>4、可见，HTTP2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。</p>
<p><strong>头部压缩</strong></p>
<p>在HTTP1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。</p>
<p>HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。</p>
<p><strong>服务器推送：</strong></p>
<p>服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p>
<p>HTTP2.0:</p>
<ul>
<li><p><strong>新的二进制格式</strong>（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
</li>
<li><p><strong>多路复用</strong>（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
</li>
<li><p><strong>header压缩</strong>，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
</li>
<li><p><strong>服务器推送</strong>：</p>
<p>服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</p>
</li>
</ul>
<h2 id="5-1、http3-0-（QUIC）用的udp"><a href="#5-1、http3-0-（QUIC）用的udp" class="headerlink" title="5.1、http3.0 （QUIC）用的udp"></a>5.1、http3.0 （QUIC）用的udp</h2><p>看下面的QUIC就可以了。</p>
<h2 id="5-2、QUIC协议-这是针对tcp"><a href="#5-2、QUIC协议-这是针对tcp" class="headerlink" title="5.2、QUIC协议(这是针对tcp)"></a>5.2、QUIC协议(这是针对tcp)</h2><p><strong>简介</strong></p>
<ul>
<li>而QUIC协议最最吸引人的特性有两点，一是对线头阻塞(HOL)问题的解决更为彻底。基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的其它与它毫不相干的流的数据的传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。</li>
<li>另一个特性切换网络时的连接保持。当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。(连接迁移，靠着一个<strong>64位的id</strong>)</li>
</ul>
<p><strong>原理</strong></p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1588818989895632410&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1588818989895632410&amp;wfr=spider&amp;for=pc</a></p>
<p>快几个rtt的原因解释</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1677802258258817086&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1677802258258817086&amp;wfr=spider&amp;for=pc</a></p>
<p>quic如何可靠安全，也就是udp如何保证可靠安全传输呢</p>
<p><strong>QUIC安全连接详解</strong><br>在阅读下面流程，需要掌握DH算法的工作流程，不熟悉的可以看下我之前俺写的一篇文章，HTTPS之TLS1.2连接详解。</p>
<p>QUIC 是 安全的， 其使用DH算法生成对称密钥。连接如下：<br>1、客户端发送Client Hello给服务器，请求DH生成密钥的参数<br>2、服务器返回对应的参数和公钥给参数给客户端<br>3、客户端收到DH参数以及服务器的公钥，生成了密钥，然后将自己公钥发给服务器。在此时，客户端已经可以利用密钥加密数据进行传输了。<br>4、服务器收到客户端的公钥后，也可以得出对应的密钥了，可以解密客户端发来的密文。</p>
<p>从上述流程看出，仅仅1个RTT，客户端和服务器就可以生成对称密钥，可以安全的进行连接了。</p>
<p>QUIC 还有进一步优化，优化到了0RTT。</p>
<p>客户端可以缓存服务器的DH参数，这样的话，客户端在进行连接的时候，就可以生成对应的密钥，然后将自己的公钥传过去。服务器同样可以利用客户端的公钥生成密钥，然后解密数据。</p>
<p>0RRT就可以建立安全连接，太好了。</p>
<p><strong>QUIC数据传输和重传</strong><br>QUIC将上层数据包，比如HTTP3数据包，分成多个帧，然后组装成一个Packet 发送。</p>
<p>每个帧都会有一个定时器，如果在规定时间内收不到对应的ack，就重传对应的帧，还是通过packet，如果有其他帧一块，就凑成一个packet，如果没有，就自己用一个packet。</p>
<h2 id="5-3-SPDY协议（这是针对http）"><a href="#5-3-SPDY协议（这是针对http）" class="headerlink" title="5.3 SPDY协议（这是针对http）"></a>5.3 SPDY协议（这是针对http）</h2><ul>
<li>多路复用请求：在单个SPDY连接能并发的发起请求，并不限制请求数；</li>
<li>请求优先级：客户端能请求某个资源被优先传输。这避免了高优先级请求被非关键资源堵塞网络通道的问题；</li>
<li>头部压缩：客户端现在发送了大量冗余的HTTP头部信息。因为一个页面可能有50到100个子请求，这些数据是巨大的；</li>
<li>服务端推送流：服务端能向客户端推送数据不需要客户端发起一个请求。</li>
</ul>
<h2 id="6、HTTPS加密流程-TLS-SSL"><a href="#6、HTTPS加密流程-TLS-SSL" class="headerlink" title="6、HTTPS加密流程,TLS/SSL"></a>6、HTTPS加密流程,TLS/SSL</h2><ol>
<li>客户端先从服务器获取到证书，证书中包含公钥</li>
<li>客户端将证书进行校验</li>
<li>客户端生成一个对称密钥，用证书中的公钥进行加密，发送给服务器</li>
<li>服务器得到这个请求后用私钥进行解密，得到该密钥</li>
<li>客户端以后发出后续的请求，都使用这个对称密钥进行加密。</li>
<li>服务器收到这个密文也用这个密钥进行解密。</li>
</ol>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220317162445588.png" alt="image-20220317162445588"></p>
<ol>
<li><p><strong>认证服务器</strong>。浏览器内置一个受信任的CA机构（Certifi<em>ca</em>te Authority）列表，并保存了这些CA机构的证书。第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥，用于后续流程。否则，浏览器将提示用户，根据用户的选择，决定是否继续。当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/philo-zhou/p/14375788.html%EF%BC%8C%E5%8C%85%E6%8B%AC%E5%9B%9E%E5%BA%94tsl%E7%89%88%E6%9C%AC%E4%BB%80%E4%B9%88%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">https://www.cnblogs.com/philo-zhou/p/14375788.html，包括回应tsl版本什么加密算法</a></p>
</li>
<li><p><strong>协商会话密钥</strong>。客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，<strong>是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源</strong>。另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。（非对称加密建立连接，对称加密传输数据）</p>
</li>
<li><p><strong>加密通讯</strong>。此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。</p>
</li>
</ol>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220317211124460.png" alt="image-20220317211124460"></p>
<h2 id="7、HTTP与HTTPS对比"><a href="#7、HTTP与HTTPS对比" class="headerlink" title="7、HTTP与HTTPS对比"></a>7、HTTP与HTTPS对比</h2><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p>
<p>端口不同：Http与Https使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p>
<p>资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p>
<p>开销：Https通信需要证书，而证书一般需要向认证机构购买；</p>
<p>Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。</p>
<h2 id="8、HTTP协议中定义的方法-动作"><a href="#8、HTTP协议中定义的方法-动作" class="headerlink" title="8、HTTP协议中定义的方法/动作"></a>8、HTTP协议中定义的方法/动作</h2><p>GET：向特定的资源发出请求。</p>
<p>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</p>
<p>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</p>
<p>PUT：向指定资源位置上传其最新内容。 /<strong>/和post区别是什么呢？</strong>要看<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_33940108/article/details/123840104">https://blog.csdn.net/sinat_33940108/article/details/123840104</a></p>
<p>DELETE：请求服务器删除Request-URI所标识的资源。</p>
<h2 id="9、HTTP状态码"><a href="#9、HTTP状态码" class="headerlink" title="9、HTTP状态码"></a>9、HTTP状态码</h2><p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>常见状态代码、状态描述、说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span> OK      <span class="comment">//客户端请求成功</span></span><br><span class="line"><span class="number">400</span> Bad Request  <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"><span class="number">401</span> Unauthorized <span class="comment">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span></span><br><span class="line"><span class="number">403</span> Forbidden  <span class="comment">//服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"><span class="number">404</span> Not Found  <span class="comment">//请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"><span class="number">500</span> Internal Server Error <span class="comment">//服务器发生不可预期的错误</span></span><br><span class="line"><span class="number">503</span> Server Unavailable  <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure>

<h2 id="10、cookie与session区别"><a href="#10、cookie与session区别" class="headerlink" title="10、cookie与session区别"></a>10、cookie与session区别</h2><p>Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p>
<p>Session 与 Cookie 的对比</p>
<p>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传Session ID；</p>
<p>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；</p>
<p>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；</p>
<p>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</p>
<p>存放位置：cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
<h2 id="11、输入一个URL到显示页面的流程"><a href="#11、输入一个URL到显示页面的流程" class="headerlink" title="11、输入一个URL到显示页面的流程"></a>11、输入一个URL到显示页面的流程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43632625/article/details/107456040">https://blog.csdn.net/qq_43632625/article/details/107456040</a></p>
<p>1.在浏览器中输入 url ，并请求</p>
<p>2.应用层解析 url</p>
<p>浏览器先查看（浏览器缓存 - 系统缓存 - 路由器缓存），如果这些缓存中有当前 url 的 web资源，则直接展示页面，如果没有，需要进行域名解析<br>域名解析（DNS解析），将域名转换为 IP地址<br>应用层生成 HTTP请求报文<br>3.传输层 TCP协议 传输报文</p>
<p>传输层的 TCP协议 提供可靠的数据传输服务<br>TCP协议 是面向连接的，所以需要 “三次握手” 建立连接<br>4.建立起连接之后，浏览器向服务器发送 HTTP请求报文</p>
<p>5.网络层 IP协议 选择路线</p>
<p>IP协议 将用户报文封装成组进行数据传输<br>ARP协议（地域解析协议），将 IP地址 解析为对应的 MAC地址，便于数据传输<br>6.数据到达数据链路层，在相邻结点间无差错的、可靠的传输数据帧</p>
<p>7.服务器接收数据，处理收到的请求，将响应返回至浏览器</p>
<p>8.浏览器接收到 HTTP响应</p>
<p>至此，从输入 url 到浏览器接收响应的过程结束。那么响应页面是如何展示的呢？</p>
<p>读取页面内容，浏览器进行渲染，解析 html源码<br>生成 Dom 树，解析 css 样式，js 交互<br>ajax 查询</p>
<h1 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h1><h2 id="1、TCP与UDP的区别与联系"><a href="#1、TCP与UDP的区别与联系" class="headerlink" title="1、TCP与UDP的区别与联系"></a>1、TCP与UDP的区别与联系</h2><ol>
<li>TCP面向连接，传输数据之前要需要建立会话。UDP是无连接的。</li>
<li>TCP提供可靠传输，保证数据不丢包、不重复且按顺序到达；UDP只尽努力交付，不保证可靠交付</li>
<li>TCP提供了拥塞控制；UDP不提供</li>
<li>TCP是面向字节流的；UDP面向报文。</li>
<li>TCP只支持点到点通信；UDP支持一对一、一对多、多对多的交互通信。</li>
<li>TCP首部开销大20字节，UDP首部开销小8字节。</li>
</ol>
<ul>
<li>tcp的可靠有什么措施</li>
</ul>
<p>握手挥手、数据分块、序列号和确认应答、校验和、流量控制、拥塞控制、超时重传</p>
<h2 id="2、TCP与UDP的应用场景"><a href="#2、TCP与UDP的应用场景" class="headerlink" title="2、TCP与UDP的应用场景"></a>2、TCP与UDP的应用场景</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203326213.png" alt="image-20220310203326213"></p>
<h2 id="3、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）"><a href="#3、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）" class="headerlink" title="3、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）"></a>3、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220228195905978.png" alt="image-20220228195905978"></p>
<p>RST 复位。</p>
<p>SYN ：同步，请求连接和确认连接时置为1</p>
<p>FIN ： 停止，断开连接确认时置为1.</p>
<h2 id="4、TCP滑动窗口"><a href="#4、TCP滑动窗口" class="headerlink" title="4、TCP滑动窗口"></a>4、TCP滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<h2 id="5、TCP超时重传时间选择"><a href="#5、TCP超时重传时间选择" class="headerlink" title="5、TCP超时重传时间选择"></a>5、TCP超时重传时间选择</h2><ul>
<li>RTT往返时间 = 开始发送时间 - 收到时间</li>
<li>RTO超时时间, 要略大于 RTT 时间</li>
<li>随着环境的不一样, RTT样本差别大, 要计算加权平均</li>
</ul>
<h2 id="6、TCP流量控制"><a href="#6、TCP流量控制" class="headerlink" title="6、TCP流量控制"></a>6、TCP流量控制</h2><p>如果发送端发送数据太快，接收端来不及接收，可能会丢失数据。所以流量控制是让发送端不要发送太快，要让接收端来得及接收（通过<strong>捎带</strong>技术，从接收端回来的信息里包含接收端的空闲信息）<br>流量控制是通过大小可变的滑动窗口实现的。窗口的大小在TCP头部的窗口字段。<br>发送端窗口大小不能超过接收端窗口大小的值。TCP窗口单位是字节。<br>为什么要设置窗口，因为如果TCP发完一次数据等待接收端确认再发下一条数据太慢了。</p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220311153240377.png" alt="image-20220311153240377"></p>
<h2 id="7、TCP拥塞控制（一定要弄清楚与流量控制的区别）"><a href="#7、TCP拥塞控制（一定要弄清楚与流量控制的区别）" class="headerlink" title="7、TCP拥塞控制（一定要弄清楚与流量控制的区别）"></a>7、TCP拥塞控制（一定要弄清楚与流量控制的区别）</h2><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。</p>
<p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。<strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</strong></p>
<p>注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种： A、慢启动 B、拥塞避免 C、快重传 D、快恢复</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<p>A、接收方有足够大的接收缓存，因此不会发生流量控制；</p>
<p>B、虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。    </p>
<p><strong>慢启动与拥塞避免</strong></p>
<p>慢启动：<br>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小，每次窗口大小为原来的二倍。<br>拥塞避免：<br>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220311155302214.png" alt="image-20220311155302214"></p>
<p><strong>快重传与快恢复</strong></p>
<p>快重传：<br>快重传要求接收方在收到一个 <strong>失序的报文段</strong> 后就立即发出 <strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br>快恢复：<br>快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢启动算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢启动算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220311155326182.png" alt="image-20220311155326182">    </p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203353775.png" alt="image-20220310203353775"></p>
<h2 id="8、TCP三次握手及状态变化。为什么不是两次握手？"><a href="#8、TCP三次握手及状态变化。为什么不是两次握手？" class="headerlink" title="8、TCP三次握手及状态变化。为什么不是两次握手？"></a>8、TCP三次握手及状态变化。为什么不是两次握手？</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203406562.png" alt="image-20220310203406562"></p>
<p>SYN：同步SYN(SYNchronization),在连接建立使用来同步序号。SYN置1表示这是一个<strong>连接请求</strong>或<strong>连接请求确认</strong>。</p>
<p>ACK：确认ACK(ACKnowledgment),仅当ACK=1时确认号字段才有效。TCP规定，<strong>在连接建立后所有的报文段都必须把ACK置1。</strong></p>
<p>seq: 序号。</p>
<p>ack: 确认号。</p>
<ul>
<li><p>最初两端的TCP进程都处于CLOSE(关闭)状态。<br>上图中A主动打开连接，B被动打开连接。</p>
</li>
<li><p>B打开连接后处于LISTEN(监听状态)，等待客户的连接请求。</p>
</li>
<li><p>A向B发送请求报文，SYN=1,ACK=0,选择一个初始序号seq=x。</p>
</li>
<li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为ack= x+1，同时也选择一个初始的序号 seq=y。</p>
</li>
<li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为ack= y+1，序号为 seq=x+1。</p>
</li>
<li><p>B 收到 A 的确认后，连接建立。</p>
</li>
<li><p>round 1 : SYN 置1 ，发送<strong>随机</strong>序列号seq = x</p>
</li>
<li><p>round2：syn = 1 , (ACK = 1 ,ack = x +1),seq = y</p>
</li>
<li><p>round3 : (syn = 0) (ACK = 1 , ack = y+1), seq = x+1  返回确认的确认，这一步可以携带数据了</p>
</li>
</ul>
<p><strong>为什么不是两次握手？</strong></p>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</p>
<p>1.“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假<strong>设不采用“三次握手”，那么只要server发出确认，新的连接就建立了</strong>。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p>2.老数据被当成新数据接受了：</p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220228213837422.png" alt="image-20220228213837422"></p>
<h2 id="9、TCP四次挥手及状态变化。为啥不是三次挥手？"><a href="#9、TCP四次挥手及状态变化。为啥不是三次挥手？" class="headerlink" title="9、TCP四次挥手及状态变化。为啥不是三次挥手？"></a>9、TCP四次挥手及状态变化。为啥不是三次挥手？</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203426979.png" alt="image-20220310203426979"></p>
<p>数据传输结束后，通信的双方都可释放连接。<br>此处为A的应用进程先向其TCP发出连接释放报文段，但是A结束TCP连接的时间要比B晚一些。</p>
<p>FIN: 终止FINs,用来释放一个连接。当FIN等于1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p>
<p>ACK: 确认ACK(ACKnowledgment),仅当ACK=1时确认号字段才有效。TCP规定，在连接建立后所有的报文段都必须把ACK置1。</p>
<p>seq: 序号。</p>
<p>ack: 确认号。</p>
<ul>
<li><p>round 1 : 客户端 发送FIN = 1 请求释放连接，发送自己的序列号seq = u ；</p>
</li>
<li><p>round2 : 服务器收到但是不能立即关，因为还有数据要发送，所以只发送ACK＝１，ａｃｋ　＝　u+1，发送自己的序列号v（这个ｖ取决于上一次发到哪里了）；</p>
</li>
<li><p>ｒｏｕｎｄ３：服务器在经过ｃｌｏｓｅ＿ｗａｉｔ　，之后可以关了，发送FIN = 1 ，ACK＝　1　，ａｃｋ　＝　ｕ＋１，ｓｅｑ　＝　ｗ（因为中间发了数据嘛）</p>
</li>
<li><p>ｒｏｕｎｄ4　：　收到连接释放请求，ＡＣＫ　＝　１　，ａｃｋ　＝　ｗ＋１，ｓｅｑ　＝　ｕ＋１；</p>
<p>在等两个ｍｓｌ　，结束连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p><strong>CLOSE-WAIT</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME-WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。</p>
<p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？</p>
<p>这么做有两个理由：</p>
<ul>
<li>为了保证A发送的最后一个ACK报文段能够到达B。<br>A发送的这个ACK报文段有可能丢失，如果 B 没收到 A 发送来的确认报文，那么A就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li>防止“已经失效的连接请求报文段”出现在本链接中。<br>A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接的时间内所产生的所有报文段都从网络中消失。这样下一个新的连接中就不会出现这种旧的连接请求报文段。</li>
</ul>
<p><strong>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p>
<p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，<strong>它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，</strong>所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p>
<h2 id="10、TCP连接释放中TIME-WAIT状态的作用"><a href="#10、TCP连接释放中TIME-WAIT状态的作用" class="headerlink" title="10、TCP连接释放中TIME_WAIT状态的作用"></a>10、TCP连接释放中TIME_WAIT状态的作用</h2><p><strong>TIME-WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。</p>
<p>为什么A在TIME-WAIT状态必须等待2MSL的时间呢？</p>
<p>这么做有两个理由：</p>
<ul>
<li><strong>为了保证A发送的最后一个ACK报文段能够到达B。</strong><br>A发送的这个ACK报文段有可能丢失，如果 B 没收到 A 发送来的确认报文，那么A就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li><strong>防止“已经失效的连接请求报文段”出现在本链接中。</strong><br>A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接的时间内所产生的所有报文段都从网络中消失。这样下一个新的连接中就不会出现这种旧的连接请求报文段。</li>
</ul>
<h2 id="11、SYN泛洪攻击。如何解决？"><a href="#11、SYN泛洪攻击。如何解决？" class="headerlink" title="11、SYN泛洪攻击。如何解决？"></a>11、SYN泛洪攻击。如何解决？</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220311104301897.png" alt="image-20220311104301897"></p>
<p>在三次握手的过程中，服务器为了响应一个受到的SYN报文段，会分配并初始化连接变量和缓存，然后服务器发送一个SYNACK报文段进行响应，并等待客户端的ACK报文段。如果客户不发送ACK来完成该三次握手的第三步，最终（通常在一分多钟之后）服务器将终止该半开连接并回收资源。</p>
<p>这种TCP连接管理协议的特性就会有这样一个漏洞，攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段的不断到来，服务器不断为这些半开连接分配资源，从而导致服务器连接资源被消耗殆尽。这种攻击就是<strong>SYN泛供攻击</strong>。</p>
<p>为了应对这种攻击，现在有一种有效的防御系统，称为<strong>SYN cookie</strong>。SYN cookie的工作方式如下：</p>
<p>(1) 当服务器接收到一个SYN报文段时，它并不知道该报文段是来自一个合法的用户，还是这种SYN洪泛攻击的一部分。因为服务器不会为该报文段生成一个半开的连接。相反，服务器生成一个初始TCP序列号，该序列号是SYN报文段的源IP地址和目的IP地址，源端口号和目的端口号以及仅有服务器知道的秘密数的复杂函数（散列函数）。这种精心制作的初始序列号称为为“cookie”。服务器则发送具有这种特殊初始序号的SYNACK报文分组。服务器并不记忆该cookie或任何对应于SYN的其他状态信息。</p>
<p>(2) 如果该客户是合法的，则它将返回一个ACK报文段。当服务器收到该ACK报文段，需要验证该ACK是与前面发送的某个SYN相对应。由于服务器并不维护有关SYN报文段的记忆，所以服务器通过使用SYNACK报文段中的源和目的IP地址与端口号以及秘密数运行相同的散列函数。如果这个函数的结果（cookie值）加1和在客户的ACK报文段中的确认值相同的话，那么服务器就会认为该ACK对应于较早的SYN报文段，因此它是合法的。服务器则会生成一个套接字的全开连接。</p>
<p>(3) 另一方面，如果客户没有返回一个ACK报文段，说明之前的SYN报文段是洪泛攻击的一部分，但是它并没有对服务器产生危害，因为服务器没有为它分配任何资源。</p>
<h2 id="12、TCP粘包"><a href="#12、TCP粘包" class="headerlink" title="12、TCP粘包"></a>12、TCP粘包</h2><p>在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。<br><strong>什么是TCP粘包问题？</strong></p>
<p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<p><strong>造成TCP粘包的原因</strong></p>
<p>（1）发送方原因</p>
<p>TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p>
<ol>
<li>只有上一个分组得到确认，才会发送下一个分组</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ol>
<p>Nagle算法造成了发送方可能会出现粘包问题</p>
<p>（2）接收方原因</p>
<p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。<br><strong>什么时候需要处理粘包现象？</strong></p>
<ol>
<li>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象</li>
<li>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</li>
</ol>
<p><strong>如何处理粘包现象？</strong></p>
<p>（1）发送方</p>
<p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<p>（2）接收方</p>
<p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<p>（2）应用层</p>
<p>应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p>
<p>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</p>
<ul>
<li><p><strong>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</strong></p>
</li>
<li><p><strong>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</strong></p>
</li>
<li><p><strong>UDP会不会产生粘包问题呢？</strong></p>
</li>
<li><p><strong>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</strong></p>
</li>
</ul>
<p>UDP则是<strong>面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题</strong>。<br>UDP不存在粘包问题，是由于UDP发送的时候，没有经过Negal算法优化，不会将多个小包合并一次发送出去。另外，在UDP协议的接收端，采用了链式结构来记录每一个到达的UDP包，这样接收端应用程序一次recv只能从socket接收缓冲区中读出一个数据包。<strong>也就是说，发送端send了几次，接收端必须recv几次（无论recv时指定了多大的缓冲区）。</strong></p>
<h2 id="13、TCP心跳包"><a href="#13、TCP心跳包" class="headerlink" title="13、TCP心跳包"></a>13、TCP心跳包</h2><p><strong>心跳包</strong>就是在客户端和服务器间定时通知对方自己状态的一个自己定义的命令字，按照一定的时间间隔发送，类似于心跳，所以叫做心跳包。用来判断对方（设备，进程或其它网元）是否正常运行，采用定时发送简单的通讯包，如果在指定时间段内未收到对方响应，则判断对方已经离线。用于检测TCP的异常断开。基本原因是服务器端不能有效的判断客户端是否在线，也就是说，服务器无法区分客户端是长时间在空闲，还是已经掉线的情况。所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。 　　比如有些通信软件长时间不使用，要想知道它的状态是在线还是离线就需要心跳包，定时发包收包。发包方：可以是客户也可以是服务端，看哪边实现方便合理，一般是客户端。服务器也可以定时发心跳下去。一般来说，出于效率的考虑，是由客户端主动向服务器端发包，而不是服务器向客户端发。客户端每隔一段时间发一个包，使用TCP的，用send发，使用UDP的，用sendto发，服务器收到后，就知道当前客户端还处于“活着”的状态，否则，如果隔一定时间未收到这样的包，则服务器认为客户端已经断开，进行相应的客户端断开逻辑处理。</p>
<p>心跳包的发送，通常有两种技术<br>方法1：应用层自己实现的心跳包<br>由应用程序自己发送心跳包来检测连接是否正常，大致的方法是：服务器在一个 Timer事件中定时 向客户端发送一个短小精悍的数据包，然后启动一个低级别的线程，在该线程中不断检测客户端的回应， 如果在一定时间内没有收到客户端的回应，即认为客户端已经掉线；同样，如果客户端在一定时间内没 有收到服务器的心跳包，则认为连接不可用。</p>
<p>方法2：TCP的KeepAlive保活机制<br>因为要考虑到一个服务器通常会连接多个客户端，因此由用户在应用层自己实现心跳包，代码较多 且稍显复杂，而利用TCP／IP协议层为内置的KeepAlive功能来实现心跳功能则简单得多。 不论是服务端还是客户端，一方开启KeepAlive功能后，就会自动在规定时间内向对方发送心跳包， 而另一方在收到心跳包后就会自动回复，以告诉对方我仍然在线。 因为开启KeepAlive功能需要消耗额外的宽带和流量，所以TCP协议层默认并不开启KeepAlive功 能，尽管这微不足道，但在按流量计费的环境下增加了费用，另一方面，KeepAlive设置不合理时可能会 因为短暂的网络波动而断开健康的TCP连接。并且，默认的KeepAlive超时需要7,200，000 MilliSeconds， 即2小时，探测次数为5次。对于很多服务端应用程序来说，2小时的空闲时间太长。因此，我们需要手工开启KeepAlive功能并设置合理的KeepAlive参数。</p>
<h2 id="14、路由器与交换机的区别与联系"><a href="#14、路由器与交换机的区别与联系" class="headerlink" title="14、路由器与交换机的区别与联系"></a>14、路由器与交换机的区别与联系</h2><p>根据 OSI模型的网络体系划分，自底向上，<strong>路由器工作在第三层（网络层）</strong>，<strong>而我们常说的交换机 工作在第二层（链路层）</strong></p>
<p>它们的主要工作如下：<br>路由器：寻址，转发（依靠 IP 地址）<br>交换机：过滤，转发（依靠 MAC 地址）</p>
<p>我们可以看出这两者的主要工作就是转发数据，但是不同之处是，依靠的地址不同，这是一个根本区别！</p>
<p>路由器内有一份路由表，里面有它的寻址信息（就像是一张地图），它收到网络层的数据报后，会根据路由表和选路算法将数据报转发到下一站（可能是路由器、交换机、目的主机）</p>
<p>交换机内有一张MAC表，里面存放着和它相连的所有设备的MAC地址，它会根据收到的数据帧的首部信息内的目的MAC地址在自己的表中查找，如果有就转发，如果没有就放弃<br><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203502069.png" alt="image-20220310203502069"></p>
<p><strong>每一个路由器与其之下连接的设备，其实构成一个局域网</strong><br>交换机工作在路由器之下，就是也就是<strong>交换机工作在局域网内</strong><br>交换机用于<strong>局域网内网的数据转发</strong><br>路由器用于<strong>连接局域网和外网</strong></p>
<p>交换机在局域网内工作，它根据 MAC 地址转发数据，如果没有了路由器在网络层寻址，那么我们的数据就不能发送到其他网络终端上去了</p>
<p>路由器内集成了交换机的功能，主机与路由器相连也可以实现数据转发，但是不足之处是：<br>可扩展的接口不如交换机多<br>交换机通常由硬件加速转发，路由器主要靠软件寻址，速度慢</p>
<h2 id="15、UDP如何实现可靠传输！！！"><a href="#15、UDP如何实现可靠传输！！！" class="headerlink" title="15、UDP如何实现可靠传输！！！"></a>15、UDP如何实现可靠传输！！！</h2><p><strong>在应用层增加可靠性</strong></p>
<p>应用特定的差错恢复</p>
<h2 id="16、tcp-udp复用解复用"><a href="#16、tcp-udp复用解复用" class="headerlink" title="16、tcp /udp复用解复用"></a>16、tcp /udp复用解复用</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220226192823773.png" alt="image-20220226192823773"></p>
<p>考得就是 IP 和 socket/port  才能找到对应的 port/socket。</p>
<p>socket1/port1/ip1/port2/ip2    ; socket2/port1/ip1/port2/ip2.</p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220226194651334.png" alt="image-20220226194651334"></p>
<p>udp的复用解复用比tcp少，socket与本地的IP和port相捆绑  </p>
<p>socket1/port1/ip1/      socket2/port2/ip2.</p>
<h2 id="17-tcp序列号"><a href="#17-tcp序列号" class="headerlink" title="17.tcp序列号"></a>17.tcp序列号</h2><p>为什么tcp需要序列号　ｓｅｑ。</p>
<h2 id="18、tcp-粘包分包的原因"><a href="#18、tcp-粘包分包的原因" class="headerlink" title="18、tcp 粘包分包的原因"></a>18、tcp 粘包分包的原因</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yaochunhui/p/14175396.html">https://www.cnblogs.com/yaochunhui/p/14175396.html</a></p>
<h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="1、地址解析协议（ARP）"><a href="#1、地址解析协议（ARP）" class="headerlink" title="1、地址解析协议（ARP）"></a>1、地址解析协议（ARP）</h2><p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<p>1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。</p>
<p>2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：<strong>源主机IP地址，源主机MAC地址，目的主机的IP地址</strong>。</p>
<p>3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。</p>
<p>4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>
<h2 id="2、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？"><a href="#2、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？" class="headerlink" title="2、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？"></a>2、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？</h2><p>当年设计出IP地址这个东西，就是因为随着网络中的设备逐渐增多，人们发现路由（也就是寻找数据包从发送方到接收方的路径）变得越来越困难了。于是人们想了一个办法，就是把网络划分成很多个子网。这样，在路由的时候，路由器可以把其他子网看成一个整体来进行计算。对于目的地在其他子网的数据包，路由器只需要让数据包到达那个子网即可，而剩下的工作就由子网内部解决了。虽然这种方法只能让寻找到的路径接近最优而不保证最优，不过它大大减少了路由器的计算量，利大于弊，所以被采用了。<br>那么为什么我们需要IP地址呢?因为如果我们只用MAC地址的话，我们会发现路由器需要记住每个MAC地址所在的子网是哪一个(不然每一次收到数据包的时候路由器都要重新满世界地去找这个MAC地址的位置)。而世界上有2^48个MAC地址，这就意味着即使我们给每个MAC地址只留1字节的储存空间，每个路由器也需要256 TB的内存!这显然是不可能实现的。<br>这就是我们需要IP地址的原因了。和MAC不同的是，IP地址是和地域相关的。对于位于同一个子网上的设备，我们给他们分配的IP地址前缀都是一样的。这个前缀就像邮政编码一样。这样，路由器通过IP地址的前缀就能知道这个设备在哪个子网上了。现在，路由器只需要记住每个子网的位置即可，大大减少了路由器所需要的内存。<br>既然IP地址不能去掉，那么能不能去掉MAC地址呢?也不能。因为IP地址是要设备上线以后，才能根据他进入了哪个子网来分配的，在设备还没有IP地址的时候(或者分配IP地址的过程中），我们还需要用MAC地址来区分不同的设备。<br>总之，MAC地址就像自己的ID号，而IP地址就像带着邮政编码的住址，各有各的用途。所以我们需要两个地址，缺一不可。</p>
<h2 id="3、网络层转发数据报的流程"><a href="#3、网络层转发数据报的流程" class="headerlink" title="3、网络层转发数据报的流程"></a>3、网络层转发数据报的流程</h2><h2 id="4、子网划分"><a href="#4、子网划分" class="headerlink" title="4、子网划分"></a>4、子网划分</h2><p><strong>1、为什么要划分子网？</strong></p>
<p>IPv4地址如果只使用有类（A、B、C类）来划分，会造成大量的浪费或者不够用，为了解决这个问题，可以在有类网络的基础上，通过对IP地址的主机号进行再划分，把一部分划入网络号，就能划分各种类型大小的网络了。</p>
<p><strong>2、IPv4子网划分与聚合</strong></p>
<p>为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是VLSM（可变长子网掩码）和CIDR（无类别域间路由），把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。</p>
<p>VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率。</p>
<p>通过VLSM实现子网划分的基本思想很简单：就是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网。</p>
<p>①把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位</p>
<p>②把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。</p>
<p>③原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。</p>
<h2 id="5、子网掩码"><a href="#5、子网掩码" class="headerlink" title="5、子网掩码"></a>5、子网掩码</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203526165.png" alt="image-20220310203526165"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><strong>1、子网掩码的概念及作用</strong></p>
<p>①子网掩码（Subnet Mask）又叫网络掩码、地址掩码，必须结合IP地址一起对应使用。<br>②只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。<br>③子网掩码和IP地址做“与”运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。<br>④子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。</p>
<p><strong>2、为什么要使用子网掩码？</strong></p>
<p>子网掩码可以分离出IP地址中的网络地址和主机地址，那为什么要分离呢？因为两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。</p>
<h2 id="6、IP地址的分类"><a href="#6、IP地址的分类" class="headerlink" title="6、IP地址的分类"></a>6、IP地址的分类</h2><p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203538104.png" alt="image-20220310203538104"></p>
<h2 id="7、ICMP"><a href="#7、ICMP" class="headerlink" title="7、ICMP"></a>7、ICMP</h2><p>ICMP是（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递<strong>控制消息</strong>。控制消息是指<strong>网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用</strong>。</p>
<p>　　它是TCP/IP协议族的一个子协议，属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括报告错误、交换受限控制和状态信息等。当遇到IP数据无法访问目标、IP路由器无法按当前的传输速率转发数据包等情况时，会自动发送ICMP消息。ICMP报文在IP帧结构的首部协议类型字段（Protocol 8bit)的值=1.</p>
<p>　　在IP通信中，经常有数据包到达不了对方的情况。原因是，在通信途中的某处的一个路由器由于不能处理所有的数据包，就将数据包一个一个丢弃了。或者，虽然到达了对方，但是由于搞错了端口号，服务器软件可能不能接受它。在IP 网络上，由于数据包被丢弃等原因，为了控制将必要的信息传递给发信方。ICMP 协议是为了辅助IP 协议，交换各种各样的控制信息而被制造出来的。</p>
<p>　　RFC792 的开头部分里写着“ICMP 是IP 的不可缺少的部分，所有的IP 软件必须实现ICMP协议。也是，ICMP 是为了分担IP 一部分功能而被制定出来的。</p>
<p>在RFC，将ICMP 大致分成两种功能：差错通知和信息查询。</p>
<p>　　1. 确认IP包是否成功到达目标地址 </p>
<p>　　2. 通知在发送过程中IP包被丢弃的原因 </p>
<p>注意点</p>
<p>1、ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议 </p>
<p>2、ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6　　</p>
<h2 id="8、PING和traceroute"><a href="#8、PING和traceroute" class="headerlink" title="8、PING和traceroute"></a>8、PING和traceroute</h2><p>有时候可能会发生Web服务器故障，网络拥塞或其他一些技术故障，这可能会阻止消息到达目的地。<strong>为了诊断此类拥塞和网络故障，我们使用两个常见程序，即Ping和Traceroute。</strong></p>
<p><strong>1、Ping</strong><br>它是一个实用程序，可以帮助人们检查特定的IP地址是否可访问。Ping通过向指定地址发送数据包并等待回复来工作。它还可以测量往返时间并报告错误。</p>
<p>Ping还用于检查本地网络上的计算机是否处于活动状态。为此，用户必须进入命令提示符并输入：ping 127.0.0.1，如果地址处于活动状态，则ping将返回如下消息：<br><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203553999.png" alt="image-20220310203553999"></p>
<p>IP地址127.0.0.1是本地主机的地址，即使发件人未连接到Internet，也会收到ping回复。（<strong>通常用来检查本地网卡是否存在故障</strong>）</p>
<p><strong>2、Traceroute</strong></p>
<p>Traceroute - 实用程序可以跟踪从您的计算机到主机的数据包，还会显示到达此处所需的步数（跳数）以及每个步骤的时间。Traceroute通过发送具有低生存时间（生存时间 - TTL）的数据包来工作，该数据包指定数据包在返回之前能够存活多少步（跳）。当数据包无法到达最终目的地并在中间步骤到期时，该节点返回数据包并标识自身。因此，通过逐渐增加TTL，Traceroute能够识别中间主机。如果任何跳转回“请求超时”，则表示网络拥塞以及加载网页和连接丢失的原因。<br><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203649734.png" alt="image-20220310203649734"></p>
<h1 id="五、链路层"><a href="#五、链路层" class="headerlink" title="五、链路层"></a>五、链路层</h1><h2 id="1、MTU"><a href="#1、MTU" class="headerlink" title="1、MTU"></a>1、MTU</h2><p>Maximum Transmission Unit，缩写MTU，中文名是：最大传输单元。</p>
<p>从下面这个表格中可以看到，在7层网络协议中，MTU是<strong>数据链路层</strong>的概念。MTU限制的是数据链路层的payload，也就是<strong>上层协议</strong>的大小，例如IP，ICMP等。</p>
<p><img src="C:\Users\zhanghui\AppData\Roaming\Typora\typora-user-images\image-20220310203705346.png" alt="image-20220310203705346"></p>
<h1 id="六、补充"><a href="#六、补充" class="headerlink" title="六、补充"></a>六、补充</h1><h2 id="1-输入一个url到响应的过程"><a href="#1-输入一个url到响应的过程" class="headerlink" title="1.输入一个url到响应的过程"></a>1.输入一个url到响应的过程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43632625/article/details/107456040">https://blog.csdn.net/qq_43632625/article/details/107456040</a></p>
<p>1.在浏览器中输入 url ，并请求</p>
<p>2.应用层解析 url</p>
<ul>
<li>浏览器先查看（浏览器缓存 - 系统缓存 - 路由器缓存），如果这些缓存中有当前 url 的 web资源，则直接展示页面，如果没有，需要进行域名解析</li>
<li>域名解析（DNS解析），将域名转换为 IP地址（DNS查询报文，udp报文段）</li>
<li>应用层生成 HTTP请求报</li>
</ul>
<p>3.传输层 TCP协议 传输报文</p>
<p>​    传输层的 TCP协议 提供可靠的数据传输服务<br>​    TCP协议 是面向连接的，所以需要 “三次握手” 建立连接<br>4.建立起连接之后，浏览器向服务器发送 HTTP请求报文</p>
<p>5.网络层 IP协议 选择路线</p>
<p>IP协议 将用户报文封装成组进行数据传输<br>ARP协议（地域解析协议），将 IP地址 解析为对应的 MAC地址，便于数据传输，让服务器知道是谁请求的。<br>6.数据到达数据链路层，在相邻结点间无差错的、可靠的传输数据帧</p>
<p>7.服务器接收数据，处理收到的请求，将响应返回至浏览器</p>
<p>8.浏览器接收到 HTTP响应</p>
<p>至此，从输入 url 到浏览器接收响应的过程结束。那么响应页面是如何展示的呢？</p>
<p>读取页面内容，浏览器进行渲染，解析 html源码<br>生成 Dom 树，解析 css 样式，js 交互<br>ajax 查询</p>
<p>加上硬件中断</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39748838/article/details/111613354">https://blog.csdn.net/weixin_39748838/article/details/111613354</a></p>
<p>加上服务端</p>
<h1 id="2、CDN"><a href="#2、CDN" class="headerlink" title="2、CDN"></a>2、CDN</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40563761/article/details/100975035">https://blog.csdn.net/qq_40563761/article/details/100975035</a></p>
<p>Cache层的技术，消除数据峰值访问造成的结点设备阻塞。Cache服务器具有缓存功能，所以大部分网页对象（Web page object）,如html, htm, php等页面文件，gif,tif,png,bmp等图片文件，以及其他格式的文件，在有效期（TTL）内，对于重复的访问，不必从原始网站重新传送文件实体, 只需通过简单的认证（Freshness Validation）- 传送几十字节的Header，即可将本地的副本直接传送给访问者。<strong>由于缓存服务器通常部署在靠近用户端，所以能获得近似局域网的响应速度，并有效减少广域带宽的消耗。不仅能提高响应速度，节约带宽，对于加速Web服务器，有效减轻源服务器的负载是非常有效的。</strong></p>
<p>根据加速对象不同，分为客户端加速和服务器加速</p>
<ul>
<li><strong>客户端加速 :</strong> Cache部署在网络出口处，把常访问的内容缓存在本地，提高响应速度和节约带宽；</li>
<li><strong>服务器加速 :</strong> Cache部署在服务器前端，作为Web服务器的代理缓存机，提高Web服务器的性能，加速访问速度。 如果多台Cache加速服务器且分布在不同地域，需要通过有效地机制管理Cache网络，引导用户就近访问(比如通过DNS引导用户)，全局负载均衡流量，这是CDN内容传输网络的基本思想。</li>
</ul>
<p>CDN对网络的优化作用主要体现在如下几个方面 　</p>
<ul>
<li>解决服务器端的“第一公里”问题 　</li>
<li>缓解甚至消除了不同运营商之间互联的瓶颈造成的影响 　</li>
<li>减轻了各省的出口带宽压力 　</li>
<li>缓解了骨干网的压力 　</li>
<li>优化了网上热点内容的分布</li>
</ul>
<p>过程（dns加了回cdn的ip)</p>
<ol>
<li>用户输入访问的域名,操作系统向 LocalDns 查询域名的ip地址.</li>
<li>LocalDns向 ROOT DNS 查询域名的授权服务器(这里假设LocalDns缓存过期)</li>
<li>ROOT DNS将域名授权dns记录回应给 LocalDns</li>
<li>LocalDns得到域名的授权dns记录后,继续向域名授权dns查询域名的ip地址</li>
<li>域名授权dns 查询域名记录后(一般是CNAME)，回应给 LocalDns</li>
<li>LocalDns 得到域名记录后,向智能调度DNS查询域名的ip地址</li>
<li><strong>智能调度DNS</strong> 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的CDN节点ip地址回应给 LocalDns</li>
<li>LocalDns 将得到的域名ip地址，回应给 用户端</li>
<li>用户得到域名ip地址后，访问站点服务器</li>
<li>CDN节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)</li>
</ol>
<h2 id="3-、怎么解释在路由器中每一个端口就是一个冲突域也是一个广播域"><a href="#3-、怎么解释在路由器中每一个端口就是一个冲突域也是一个广播域" class="headerlink" title="3 、怎么解释在路由器中每一个端口就是一个冲突域也是一个广播域"></a>3 、怎么解释在路由器中每一个端口就是一个冲突域也是一个广播域</h2><p>在以太网中，如果某个一个CSMA/CD网络上的两台计算机在同时通信时会发生冲突，那么这个CSMA/CD网络就是一个冲突域。使用路由器可有效避免冲突。因为路由器可以利用物理地址进行选路，它的每一个端口为一个冲突域。<br>路由器可以分割广播域。由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。所以路由器中的每一个端口也是一个广播域。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" data-id="cl8nwglv80000wgw035emgsl5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-second" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/30/second/" class="article-date">
  <time datetime="2022-09-30T02:48:21.000Z" itemprop="datePublished">2022-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/30/second/">second</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/30/second/" data-id="cl8nvyptw00008ow0bmpvdnx9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-my-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/30/my-test/" class="article-date">
  <time datetime="2022-09-30T02:26:39.000Z" itemprop="datePublished">2022-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/30/my-test/">my_test</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、计算机网络结构"><a href="#一、计算机网络结构" class="headerlink" title="一、计算机网络结构"></a>一、计算机网络结构</h1>
        
          <p class="article-more-link">
            <a href="/2022/09/30/my-test/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/30/my-test/" data-id="cl8nv7j0q000074w0f84q3oiq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-my_first" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/29/my_first/" class="article-date">
  <time datetime="2022-09-29T14:39:22.100Z" itemprop="datePublished">2022-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/29/my_first/">我的第一篇博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/29/my_first/" data-id="cl8n5y7ll0001psw06bvw2jti" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/09/29/hello-world/" class="article-date">
  <time datetime="2022-09-29T04:50:30.821Z" itemprop="datePublished">2022-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/09/29/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/09/29/hello-world/" data-id="cl8n5y7lf0000psw08nyr6s4m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/09/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/09/30/second/">second</a>
          </li>
        
          <li>
            <a href="/2022/09/30/my-test/">my_test</a>
          </li>
        
          <li>
            <a href="/2022/09/29/my_first/">我的第一篇博客</a>
          </li>
        
          <li>
            <a href="/2022/09/29/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 zhanghui<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>